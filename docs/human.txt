┌───────────────────────────────────┐
│                                                                      │
│              HumanOS Work Area         Version  0.20                 │
│                                        last update     93.03.12      │
│                                                                      │
└───────────────────────────────────┘

1800-1bff       DOS callベクタ・テーブル(4バイト毎)

		1bc0(L):DOS call $fff0:exitvc 
		1bc4(L):DOS call $fff1:ctrlcv ctrl-c abort
		1bc8(L):DOS call $fff2:errjvc error abort address
		1be0(L):DOS call $fff8:open_pr
		1be4(L):DOS call $fff9:kill_pr
		1bfc(L):DOS call $ffff:change_pr
		  上記ベクタに関しては処理を乗っ取るのではなくユー
		ザー処理ルーチンが本来の処理に加えてコールされる
		だけである。

1c00(L)         現在のプロセスにおけるメモリ最終アドレス+1
1c04(L)         現在のプロセスにおけるメモリ先頭アドレス
1c08(W)         inDOSフラグ
1c0a(B)         実行中のDOSコールファンクションNo.
		(非マルチタスク環境下では、inDOSフラグが
		0から1に変わるタイミングでしかセットされない)
1c0b(B)		CONFIGのNEWFATで指定した値(0 or 2)無指定時の初期値は
		$6815の値である。(FORMAT.Xが書き込む?)
1c0c(W)		IOCTRL(11)第１パラメータ(初期値:3)
1c0e(W)		IOCTRL(11)第２パラメータ(初期値:100)
1c10(W)         Verifyフラグ
1c12(B)         Break Flag
1c13(B)         Ctrl-P Flag
1c14(B)         プロセス切り替えのタイミングであることを示すフラ
		グ
1c15(B)         カレントドライブNo.
1c16(B)         stop key関連(trap #11 stop key)
			bit7
			bit0
1c17(B)         trap #10 reset/power off hookに来たら1になるフラ
		グ。これが1だと各種(?)終了処理後reset(?)
1c18(L)         trap #10 reset/power offのhookに入った時にd0を退
		避しておく。(reset or power off 判定flag ?)
1c1c(L)         最終デバイスのデバイスヘッダへのポインタ
1c20(L)		HUMAN.SYSのMCBアドレスを指している(メモリチェイ
		ンの先頭という方が適切かもしれない。)
1c24(L)		HUMAN.SYSのメモリブロックが実際にはどこまで使わ
		れているのかをポイントしている。スーパーバイザ領
		域はこの値を元に8KBバウンダリし設定される。
1c28(L)		現在のプロセスのPSPアドレスを格納してあるワーク
		を指すポインタ(例:HUMAN2.03'92だと$12b54で、
		$12b54には現在のプロセスのPSPアドレスが格納され
		ている。)
1c2c(L)		標準FCB以外(fh>5)のFCB index tableへのポインタ
		(buffers end+1でもある)
1c30(L)		FCB tableへのポインタ
		(extra fcb index table end +1)
1c34(L)		???ptr
1c38(L)         カレントディレクトリテーブルへのポインタ
1c3c(L)         物理デバイス情報テーブルへのポインタ
1c40(L)		share 管理構造体 top ptr
1c44(L)		common ptr
1c48(L)		common ptr
1c4c(L)		common ptr(end of buff ?)
1c50(L)		プロセス構造体テーブル・トップへのポインタ
1c54(L)		現在のプロセスのプロセス構造体へのポインタ
1c58(W)		最大プロセス数(CONFIG.SYSでの'PROCESS='の第一引
		数で指定した値-1)
1c5a(W)		現在生成されているプロセスの数
1c5c(L)         DOSコール時のベクタブランチ直前のA7の値(inDOSフラグが
		0から1に変わるタイミングでしかセットされない)
1c60(W)         アボート時のSR
1c62(L)         アボート時のSSP
1c66(L)         デフォルトのtrap #11(stopkey job)処理ルーチンへのポインタ
1c6a(L)         デフォルトのtrap #10(reset/poweroff job)処理ルー
		チンへのポインタ(ROMを指している。JMPさせるとIPLする。)
1c6e(W)         最大ハンドルNo.(files設定値+2)
1c70(W)		BUFFERS第２パラメータ(初期値:$6804の内容)
1c72(B)		buffers第一パラメータ
1c73(B)         ラストドライブのドライブ番号(lastdrive=の内容)
1c74(B)		ドライブ数関連(初期値:$6807の内容)
1c75(B)		接続されているdrive数？
1c76(W)		share n files(デフォルト$680a):～93
1c78(W)		share n areas(デフォルト$680c):～266
1c7a(L)		share::(share_n_areas)*12+$5c１つの管理バッファ
		あたりの容量
1c7e(B*26)      ドライブ配置テーブル(ドライブ番号変換用)
1c98(L)         open したfcb:buffer flush関係??ポインタ
1c9c(L)         open したfh :buffer flush関係??
1ca0(B)         exec関連フラグ
1ca1(B)		DOS _EXECのモード
1ca2(B)		INS key on/off flag
1ca3(B)		?(error関連:trap #14する前に0、後に-1)
1ca4(L)		getc ? buff read_ptr
1ca8(W)		getc ? buff rest_count
1caa(L)         exec関連ポインタ(mcb+$100)
1cae(L)         プロセスのexitコード
1cb2(L)         最後に実行したコマンドライン文字列へのポインタ
1cb6(L)         CLOCKデバイスのデバイスヘッダへのポインタ
1cba-67ff	****HUMAN 2.03まででは未使用領域のはず***
6800		HUMAN.SYS開始アドレス(OS スタック下限?)
*---------------------------------------------------*
*   以下、各種デフォルト値が設定されている。        *
*---------------------------------------------------*
6802(B)		files			(15)	
6803(B)		buffers nbuff		(20)	2-249
6804(W)		buffers buffsize	(1024)	1024-32768
6806(B)		lastdrive		(25)	
6807(B)		drives関連		(25)	
6808(B)		break_mode		(0)	
6809(B)		verify_flag		(0)	
680a(W)		share_n_files		(0)	
680c(W)		share_n_areas		(0)	
680e(L)		common			(0)	?-1024(1024kb)
6812(B)		process arg1		(0)	
6813(B)		process arg2		(0)	
6814(B)		process arg3		(0)	
6815(B)		newfat			(0)	
*------------------------------------------------------------*
* [以下、HUMAN 2.02でのアドレス:2.03('92)でのアドレス]       *
*   HUMAN 2.03('91)の場合は2.03('92)から-2したアドレス       *
*------------------------------------------------------------*
?????:07d50		HUMAN.SYSのMCB
?????:07d58		HUMAN.SYSのMCB.memend(supervisor limit
			addressでもある。)
?????:07d60		HUMAN.SYSのPDB
*-----------------------------------------------*
*  マルチタスク関連                             *
*-----------------------------------------------*
?????:0e914(W)		プロセス切り替えが、DOS callによるものであるのか、
			割り込みによるものかのフラグ(0でDOS call)
?????:0e916(L)		NMIベクタ保存ワーク
?????:0e91a(L)		タイム・カウンタ(10ms毎に+1)
?????:0e91e(L)		???
?????:0e922(B)		レベル・カウンタ
?????:0e923(B)		レベル・カウンタのインターバル値
?????:0e924(L)		プロセス間通信バッファへのポインタ
?????:0e938(B*16)	プロセス名
?????:0df4c		Timer-D interrupt handler entry
?????:0df88		DOS call終了のタイミングでのCHANGE_PR
?????:0e122		NMI interrupt handler entry(kill_pr/change_prの間)
?????:0e12a		NMI interrupt handler entry(normal)
?????:0e680		IOCS _TIMERDST hook entry
?????:0e766		trap #14 errordisp handler entry
?????:0e6a0(B)		inNMI flag
?????:0e6a1	***even alignment***
?????:0e6a2(L)		NMI vector保存ワーク
?????:0e6a6(L)		_TIME_PRの戻り値
?????:0e6aa(L)		old time
?????:0e6ae(B)		time slice level (current)
?????:0e6af(B)		time slice level (default)
?????:0e6b0		HUMAN.SYSのプロセス間通信バッファ構造体
?????:0e6c4		HUMAN.SYSのPROCESS名
*-----------------------------------------------*
*  内蔵デバイス・ドライバ                       *
*-----------------------------------------------*
?????:0eac2		NUL デバイス entry
?????:0eb5a		CON デバイス entry
?????:0f6e6		AUX デバイス entry
?????:0f7c0		PRN デバイス entry
?????:0f82a		LPT デバイス entry
?????:0f8e0		CLOCK デバイス entry
?????:0f9d0		DISK2HD デバイス entry
*----------------------------------------------------*
*   以下、データ領域                                 *
*----------------------------------------------------*
?????:0fedc(L)		malloc ptr(process[0].uspのためのエリア$f0バイト)
?????:0fee0(B)		?
?????:0fee1(B)		?
?????:0feee(B*256)	デフォルトのSHELL('COMMAND /P')
?????:0ffdf(S)		
?????:0fffa(S)		
?????:10009(S)		
?????:10027(S)		
?????:10029(S)		
?????:10038(S)		'^C'
?????:1003a(S)		$0d,$0a,$00
?????:1003e(B*4)	?
?????:10042(S)		'path='
?????:10048(B)		?
?????:10049(S)		DOS EXECで検索する拡張子テーブル
?????:10050(S)		DOS EXECで検索する際に補完する'.*'
?????:10054(B)		?
?????:10055(B*9)	?
*----------------------------------------------------*
*    error disp handlerで使用される領域              *
*----------------------------------------------------*
?????:1005e(W*2)	error handler message x,y position
?????:10062(W*2)	error handler message x,y position
?????:10066(W*2)	error handler message x,y position
?????:1006a(W*2)	error handler window x,y position
?????:1006e(S)		error handler message
?????:10078(S)		..
?????:10087(S)		..
?????:1008d(S)		..
?????:10093(S)		..
?????:10096(S)		..
?????:100cb(S)		bus error
?????:100e8(S)		address error
?????:10105(S)		undef. inst.
?????:10122(S)		0 div.
?????:1013f(S)		chk
?????:1015c(S)		trapv
?????:10179(S)		特権命令
?????:10196(S)		interrupt
?????:101b3(S)		float package未登録
?????:101d0(S)		unit no. illegal
?????:10205(S)		disk not ready
?????:1023a(S)		illegal command sending for device driver
?????:1026f(S)		crc error
?????:102a4(S)		disk管理領域破壊
?????:102d9(S)		seek error
?????:1030e(S)		illegal media
?????:10343(S)		sector not found
?????:10378(S)		printer not redy
?????:103ad(S)		write rror 
?????:103e2(S)		read error
?????:10417(S)		error occured
?????:1044c(S)		protect
?????:10481(S)		not writetable
?????:104b6(S)		sharing 違反
?????:104ec(W)		error handlerで保存／復元されるcontrast値
			のためのワーク
?????:104ee(W*16)	error handlerで保存・復元されるtext
			palet値のためのワーク
?????:1050e(W)		error handlerでabort選択で1になる。palet
			の復元をするかなどのフラグとして利用
?????:10510(W*4+L)	keep(x,y),set(x,y),size
?????:1051c(B*1664)	text plane 0 get/put buffer
?????:10b9c(B*1664)	text plane 1 get/put buffer
?????:1121c(B*10)	itohex output buffer
*-----------------------------------------------------*
*  con device で使用される領域                        *
*-----------------------------------------------------*
?????:11226(B*15)	check table(knjctrl)
?????:11235(B*5)	check table(knjctrl)
?????:1123a(B*5)	check table(knjctrl)
?????:11250(L)		???ptr
?????:11254(B*32)	???
?????:11274(W)		?
?????:11276(W)		sftsns status
?????:11278(B*8)	rmacnv a1
?????:11280(B*8)	rmacnv a2
?????:11288(B)		?
?????:11289(B)		?
?????:1128a(B*1536)	hendsp text plane 0 get/put buffer
?????:1188a(B*1536)	hendsp text plane 1 get/put buffer
?????:11e8a(B*1280)	hendsp text plane 0 get/put buffer
?????:1238a(B*1280)	hendsp text plane 1 get/put buffer
?????:1288a(B)		(conctrl)
?????:1288b(B)		(conctrl)
*-----------------------------------------------------------*
*                                                           *
*-----------------------------------------------------------*
?????:1288c(B*712)	function key define data
12dc8:12b54(L)		カレントPSPポインタ
12dcc:12b58(B*12)	fh使用・未使用のビットマップ
12dd8:12b64(W*5)	fcb関連
12de2:12b6e(W*5)	dos standard i/o(fno=0-4)fcb index table
12dec:12b78(W)		fh=5のFCBindex
12dee:12b7a(B*96*5)	standard i/o FCB structure(96bytes) * 5
			12b7a :stdin
			12bda :stdout
			12c3a :stderr
			12c9a :stdaux
			12cfa :stdprn
12fce:12d5a(B*96)	fh=5のFCB
1302e:12dba(B*260)	??? (byte map ???)
13132:12ebe(B)		break mode(on/off/kill)... boot時の一時的ワーク
?????:12ec0(L)		bind_fh(bindfile openflag:closeされると-1)
?????:12ec4(L)		DOSコール初期エントリテーブル
─────────────────────────────────────


1c5c(L)         DOSコール時のベクタブランチ直前のA7の値

        実際のスタックフレーム

        ┌────────┐
        │      d1        │
        ├────────┤
        │      d2        │
        ├────────┤
        │      d3        │
        ├────────┤
        │      d4        │    DOSCALLのINTVCSなどでベクトルを奪った処理
        ├────────┤    ルーチンで直接レジスタに値を返したい場合は
        │      d5        │    1c5cよりポインタを取り出し、該当する位置に
        ├────────┤    値をセットしてリターンするだけで後はDOSが
        │      d6        │    勝手に処理する。
        ├────────┤
        │      d7        │
        ├────────┤
        │      a0        │
        ├────────┤
        │      a1        │
        ├────────┤
        │      a2        │
        ├────────┤
        │      a3        │
        ├────────┤
        │      a4        │
        ├────────┤
        │      a5        │
        ├────────┤
        │      a6        │
        ├────────┤
        │      sr        │
        ├────────┤
        │      pc        │
        └────────┘


────────────────────────────────────

0000 1c38       カレントディレクトリテーブルへのポインタ

     ┌────┐      ┌───→  ┌────────┐  ┐
     ├        ┤───┘          │     a:用       │  ├─ 長さ=4e(78byte)
     └────┘                  ├────────┤  ┘
  カレントディレクトリ             │     b:用       │
  テーブルへのポインタ           ┌├────────┤
                               ┌┤│     c:用       │
                               │└├────────┤
                               │  │       .        │
                               │  │       .        │
                               │  │       .        │
                               │  │       .        │
     ┌───────┐ 0  ┐  │  │       .        │
     │              │    │  │  │       .        │
     │              │    │  │  │       .        │
     │              │    │←┘  │       .        │
     │              │    │      │       .        │
     │              │    │      │                │
     │              │    │      ├────────┤
     │              │    │      │     z:用       │
     │      1       │    │      └────────┘
     │              │    │
     │              │    │
     │              │    │
     │              │    │      1.  現在のカレントパスをフルパスで示す
     │              │    │          (仮想ドライブの場合はマウントされている
     ├───────┤+64 │          ドライブのディレクトリ名)
     │              │    │          区切記号は$09が'\'の代わりに使われている
     │      2       │    │          ターミネータはNULL
     ├───────┤+68 │      2.  常にNULL
     │      3       │    │      3.  常に0
     ├───────┤+69 │      4.  仮想ドライブ情報
     │      4       │    │              40:リニアドライブ
     ├───────┤+70 │              50:仮想ドライブ
     │              │    │              60:仮想ディレクトリ
     │      5       │    │      5.  物理デバイス情報へのポインタ
     ├───────┤+74 │      6.  常にFFFF(z:は0000になっている)
     │      6       │    │      7.  常に0002
     ├───────┤+76 │
     │      7       │    │
     └───────┘+78 ┘



────────────────────────────────────

0000 1c3c               物理デバイス情報テーブルへのポインタ

            ┌──────┐            ┌──→┌────┐ ┐
            ├            ┤──────┘      │        │ │
            └──────┘                    │  a:用  │ │長さ=1e(30byte)
   物理デバイス情報テーブルへのポインタ         ├────┤ ┘
                                                │        │
                                                │  b:用  │
      ┌────┬────┐ 0    ┐      ┌    ├────┤
      │        │        │      │      │    │        │
      ├────┴────┤ 2    │    ┌┤    │  c:用  │
      │                  │      │    │└    ├────┤
      │                  │      │    │      │        │
      ├─────────┤ 6    │    │      │  d:用  │
      │                  │      │    │      ├────┤
      │                  │      │    │      │   .    │
      ├─────────┤ a    │    │      │   .    │
      │                  │      │    │      │   .    │
      ├─────────┤ c    │    │      │   .    │
      │                  │      │    │      │   .    │
      ├─────────┤ e    │    │      │   .    │
      │                  │      │    │      │   .    │
      ├────┬────┤10    │←─┘      │   .    │
      │        │        │      │            ├────┤
      ├────┴────┤12    │            │        │
      │                  │      │            │  z:用  │
      ├─────────┤14    │            └────┘        
      │                  │      │
      ├─────────┤16    │
      │                  │      │
      ├─────────┤18    │
      │                  │      │
      ├────┬────┤1a    │
      │        │        │      │
      ├────┴────┤1c    │
      │                  │      │
      └─────────┘      ┘
    物理デバイス情報(DPBのたね)

         0      (byte)          装置番号
         1      (byte)          ユニット番号
         2      (long)          デバイスヘッダへのポインタ
         6      (long)          次のテーブルへのポインタ
         a      (word)          1セクタ当りのバイト数
         c      (word)          1クラスタ当りのセクタ数-1
         e      (word)          FATの先頭セクタ番号
        10      (byte)          FAT領域の数
        11      (byte)          1個のFAT領域に使用するセクタ数
        12      (word)          ルートディレクトリのエントリ数
        14      (word)          データ部先頭セクタ番号
        16      (word)          総クラスタ数+1
        18      (word)          ルートディレクトリ先頭セクタ番号
        1a      (byte)          メディアバイト
        1b      (byte)          ???
        1c      (word)          常に0002


────────────────────────────────────

0000 1c7e               ドライブ配置テーブル(ドライブ番号変換用)

      ┌────────┐  ┐
      │     a:用       │  ├─ 長さ=1(1byte)
      ├────────┤  ┘
      │     b:用       │
      ├────────┤
      │     c:用       │          ドライブ名に対して現在実際に割り当てられて
      ├────────┤          いるドライブ番号がそれぞれ格納されている。
      │       .        │          (ドライブ A:=$00, B:=$02, ... Z:=$19)
      │       .        │
      │       .        │          drive.x で入れ替えるとこのテーブルが変更さ
      │       .        │          れる。故意に同じ番号をセットしたりすると動
      │       .        │          作がおもしろい。
      │       .        │
      │       .        │
      │       .        │
      │       .        │
      │                │
      ├────────┤
      │     z:用       │
      └────────┘


────────────────────────────────────


この内容はある日、私がトイレで頭をぶつけたとき神のお告げにより突如閃き判った
内容なのでシャープ(株)やハード損から出た正式な内容ではありません。当然ながら
シャープ、ハドソンまたはその関係する会社に問い合わせたり、関連する書籍の会社
に問い合わせたりしてはだめなのだ。(問い合わせたらバカにされるだけなのだ)

この内容に関しては一切保証できないのだ。
この資料は煮るなり焼くなり御勝手にどーぞ。

追記しようが転載しようが仕事で使おうが売ろうが私のしったこっちゃないのだ。
空白とクエスチョンの所に誰か埋めてもらえると嬉しいのだ。

--------------------------------------------------------------------------
--------------------------------------------------------------------------
--------------------------------------------------------------------------
append by Bun.

[S_PROCESSにより確保されるプロセスメモリ空間の構造]
  単に大元のメモリブロックの属性が$fdになって、そのブロックを細
  切れにわけていっているだけ。ヘッダや構造に関しては通常のメモリ
  ブロックと同様で単にチェインがサブメモリで完結しているだけ。

  +--------------------------+
  |   MCB  属性:$fd          |
  ++------------------------++
  || sub mem MCB            ||
  |+------------------------+|
  || sub mem 実態           ||
  |+------------------------+|
  |sub mem 空き(==mem空き)   |
  +--------------------------+

	submemtop.prev=submemtop.parent=0である

[メモリブロック属性]
	$ff:	常駐メモリブロック(KEEP)
	$fe:	？？？(MEMDRV)
	$fd:	サブメモリブロック(???)


[X形式実行ファイルに関して]
  +$00(W)	MAGIC
  +$02(W)	memory allocate mode
  +$3c(L)	BINDOFST:BIND infoまでのオフセット

  memory allocate mode
	bit 0-1:
		00::normal
		10::high mem(MALLOC2(2))
		01::minimum mem(MALLOC2(1))

	ただし、Human 2.03まではバグがあり、bit1=1のhigh memしか
	有効ではない。かつ、bit0のビット位置に関しては推測でしかない。
	(何故かbtstしているのが同じビットだというマヌケなコード
	なので本当はどのビットなのかわからん。HUMAN V3を解析すれ
	ばわかるかな？)

[Z形式実行ファイル属性に関して]

  +$00(W)	ZMAGIC		ZMAGIC=$601a ?
  +$02(L)	code size
  +$06(L)	data size
  +$0a(L)	bss size
  +$16(L)	load base
  +$1a.w	d5
  total $2c bytes


[PSP(PDB?)]
  +$64(B)	EXEC_MODE
	  そのプロセスを呼んだ親プロセスのEXECしたモード$1ca1の
	値がコピーされる。
	  SETPDB()だとかそういうのででっち上げた場合にどうなるの
	かは不明である。

  +$24:(12byte)	fh_used
	  Cとかでのstructをみるとlong*3で定義しているようだが、
	実際にはbitmapでfhの使用・未使用状態が設定されている。
	fh maxが96なので、96/8=12=4longと辻褄はあっているが。
	bit位置は
		offset:fh/8
		bitpos:fh%8
	である。

	  このビットマップはそのプロセスがオープンしたfhが登録さ
	れるものであって、他のプロセスがオープンしたものに関して
	はビットマップは当然ながら更新されない。

[share 管理構造体]

  struct _share_area {
    +0(L):offset
    +4(L):len
    +8(L):fcb ptr
  };

  struct _share_file {
	+2.w :		lock count
	その他未解析****
	***** total  $5c bytes
	struct _share_area area[SHARE_NAREA]
  } _share_file share_buff[SHARE_NFILES];

   unlockする場合、_share_areaの登録は詰められる。
     [lock1][lock2][lock3]	lock_count=3
  で[lock2]をunlockすると
     [lock1][lock3]		lock_count=2
  になる。

[common領域]
  commonの最大は1024(1024kb)



[buffer領域]
	nbuff    2-249
	buffsize 1024-32768(1KB-32KB)

    struct _buffer {
     struct _buffer *next;	** end -> -1
     long           ???
     struct _buffer *prev;	** top -> -1
     long           ???
     char           buff[buffsize]
    } buffer;

[FCB index table]
  +0.b : fh
  +1.b : fh

[FCB]
  +$00.B : link counter
  +$01.B : bit7::??lock関係でもチェックが入るビットだが...
  +$02.L : device head address
  +$0a.L : LOCK bufferへのポインタ

  96 bytes

  FCBは未解析...

----------------------------------------------------------------
[現在まで確認されているHUMANのバグ(2.03)]

 *  RMDIRで仮想ドライブに割り当てている実ディレクトリが削除出来
  てしまう。内部では($1c38)のテーブルでチェックして弾く処理があ
  るようなのだが、そのテーブルに登録されているパス名の表記は最後
  にパス区切り文字('\'の内部表現$09)がつく形であるのにかかわらず、
  RMDIRが正当な引数として認めるのは最後にパス区切り文字が付かな
  い形であり、その違いが考慮されていないので常にチェックが失敗し
  ているようだ。

 *  仮想ドライブ関係で言うと、RENAME出来てしまうのも限り無くバグ
  に近い仕様だと思ってしまうのだが、これは解析していない。

 *  RMDIRには別のバグも潜伏しているかもしれない。

 *  X形式ヘッダの説明で書いたように、EXECの拡張機能のうち、最小
  限のメモリ領域に読み込む処理が機能していないようだ。


  ※HUMAN 2.02でもこれらのバグは存在する。

  ※  HUMAN 2.02→2.03のBUG-FIXに関しては昔全部調べ尽くしたのだが、
    資料がどこかにいってしまったので不明。

  ※  なお、上記RMDIRの仮想ドライブチェックは全くTwentyOneが対応
    していない箇所なので、+T / +C / +P など使っていて８文字目ま
    で同一のファイル名など危なそうなファイル名だと正常な動作をし
    ない(さほど実害はないのだが)。

--------------------------------------------------------------
[HUMAN V3]

  *  まだ解析してないが、拡張されたDOS callを１つだけ・・・。
     $ffab
	引数 word

	ASK V3でFFLUSHした後に$f01,f02,f03のそれぞれを引数にもち
	３度コールされる。HUMANがV2であった場合はそこはスキップ
	されるようになっているので、多分V3で増えたFASTIO関係のバッ
	ファ・フラッシュだと思われる。

--------------------------------------------------------------
<ワークの追加>
1cba(B)                fflush_flag(0ならfflushしない):HUMAN 3.00以降

<DOS call:新規>

        $ff7a(ffba)     引数:(short md)
                fflush modeを設定。
                        -1なら現在の状態を読む
                        (config.sysの'fflush='参照)

        $ff7b($ffbb)    引数:(short arg1, long ptr)
                arg1の上位バイト:mode
                        0       設定
                        !0      呼び出し(?)
                arg1の下位バイト:no
                        1: ex-fcbの$18.lをクリアした後で...
                        2: ex-fcbの$44.lからの7longを$0000_00ffにしたあとで...
                        3: 
                        4: 
                ptr
                        -1なら現在の設定してあるベクタ
                        デバイス・ドライバ形式のヘッダ構造トップを指すポインタ
                戻り値:
                        no不正の時は$fffffff2がエラー値で返る
                        mode=0の時は以前のの値(アドレス)が返る
                        mode!=0の時は呼び出した先の戻り値

                *FAST関連の設定だろうと思われる...

        $ffab:
                Human.sys自体ではなく外部で追加される？FAST関係だと思うが...


<DOS call:変更>

        MALLOC2(short md, ...)
                引数md(W)の最上位ビット(bit15)が...
                        1       引数が一つ増える:md(W),size(L),adrs(L)
                        0       以前と同様の動作(引数はmdとsizeのみ)

                  最上位ビットが1の場合は、adrsの値にmcb.parentを指定
                できる。つまり、mcbの親子関係をユーザー側で設定出来ると
                いうこと。ただしadrsの値が正常かどうかなどチェックは行
                なわれないので、下手なことをするとmcbの親子関係が破綻し
                てしまうだろう。別に普通は使い道があるとも思えん。多分、
                使うとすれば常駐もので、後でバッファ可変にする場合に、
                コントロールプログラム側でmallocしてやるとかそういう感
                じだろう。

FILES
        引数のatr(W)で上位バイトが1かどうかで動作が若干違う...なんか怪しい。
        1なら$3fで!1なら$20ってことはデフォルトのマスク関係なのだろうか？
        謎である。---ちなみにこれはV2時代の拡張のはず。環境ハンドブック
        以外に資料持ってないので、プログラマーズマニュアルあたりで公開され
        てる機能なのかどうか知らんから…^^;;

<その他>
        EXEC(5)         なんとなくかわってる気配が...
        IOCTRL関係?
        ファイル周りはゴチャゴチャいじくられてるので解析が面倒だ。
        FASTのからみで、FASTOPEN.Xとかも調べないとわからんし...

<bugs>
        68010以降の場合PDBのabort sspかどっかの設定がおかしいか
        もしれない。

        mkdirのバグは取れてないような気が...
